\chapter{Using the system}
\label{chapter.systemuse}

\scalaris{} can be used with one of the provided command line interfaces or
by using one of the APIs in a custom program. The following sections will
describe the APIs in general, each API in more detail and the use of our
command line interfaces.

\section{Application Programming Interfaces (APIs)}
\label{chapter.systemuse.apis}

Currently we offer the following APIs:
\begin{itemize}
  \item an \emph{Erlang API} running on the node \scalaris{} is run\\
        (functions can be called using remote connections with distributed
        Erlang)
  \item a \emph{Java API} using Erlang's \code{JInterface} library\\
        (connections are established using distributed Erlang)
  \item a generic \emph{JSON API}\\
        (offered by an integrated HTTP server running on each \scalaris{} node)
  \item a \emph{Python API} for Python >= 2.6 using JSON to talk to \scalaris{}.
  \item a \emph{Ruby API} for Ruby >= 1.8 using JSON to talk to \scalaris{}.
\end{itemize}

Each API contains methods for accessing functions from the three layers
\scalaris{} is composed of.  Table~\ref{tab.api.layers} shows the modules
and classes of Erlang, Java, Python and Ruby and their mapping to these
layers. Details about the supported operations and how to access them in
each of the APIs are provided in Section~\sieheref{sec:apis.ops}. A more
detailed discussion about the generic JSON API including examples of JSON
calls is shown in Section~\sieheref{sec.api.json}.

\begin{table}
  \centering
    \begin{tabular}{p{2cm}llll}
    \toprule
      & Erlang                 & Java                         & JSON                & Python / Ruby              \\
      & \footnotesize{module}  & \footnotesize{class in \code{de.zib.scalaris}}%
                                                              & \footnotesize{file in \code{<URL>/api/}}%
                                                                                    & \footnotesize{class in module \code{scalaris}} \\
    \midrule
    \multirow{3}{2cm}{Transaction\\Layer}
      & \code{api_tx}          & \code{Transaction},          & \code{tx.yaws}      & \code{Transaction},        \\
      &                        & \code{TransactionSingleOp}   &                     & \code{TransactionSingleOp} \\
    \cmidrule(lr){1-5}
    \multirow{2}{2cm}{Replication\\Layer}
      & \code{api_rdht}        & \code{ReplicatedDHT}         & \code{rdht.yaws}    & \code{ReplicatedDHT}       \\
      &                        &                              &                     &                            \\
    \cmidrule(lr){1-5}
    \multirow{4}{2cm}{P2P Layer}
      & \code{api_dht}         &                              &                     &                            \\
    %\cmidrule(lr){2-5}
      & \code{api_dht_raw}     &                              & \code{dht_raw.yaws} &                            \\
      & \code{api_vm}          & \code{ScalarisVM}            &                     &                            \\
      & \code{api_monitor}     & \code{Monitor}               & \code{monitor.yaws} &                            \\
    \bottomrule
    \end{tabular}
    \caption{Layered API structure}
    \label{tab.api.layers}
\end{table}

\subsection{Supported Types}

Different programming languages have different types. In order for our APIs
to be compatible with each other, only a subset of the available types is
officially supported.

\emph{Keys} are always strings. In order to avoid problems with different
encodings on different systems, we suggest to only use ASCII characters.

For \emph{values} we distinguish between \emph{native}, \emph{composite}
and \emph{custom} types (refer to Table~\ref{tab.api.supported_types} for the
mapping to the language-specific types of each API).

\emph{Native} types are
\begin{itemize}
  \item boolean values
  \item integer numbers
  \item floating point numbers
  \item strings and
  \item binary objects (a number of bytes).
\end{itemize}

\emph{Composite} types are
\begin{itemize}
  \item lists of the following elements:
  \begin{itemize}
    \item native types \emph{(except binary objects!)},
    \item composite types
  \end{itemize}
  \item objects in JavaScript Object Notation (JSON)\footnote{see \url{http://json.org/}}
\end{itemize}

\emph{Custom} types include any Erlang term not covered by the previous types.
Special care needs to be taken using custom types as they may not be accessible
through every API or may be misinterpreted by an API. The use of them is
discouraged.

\begin{table}
  \centering
  \begin{threeparttable}[b]
    \begin{tabular}{llllll}
    \toprule
               & Erlang            & Java                         & JSON                            & Python                    & Ruby \\
    \midrule
    boolean    & \code{boolean()}  & \code{bool}, \code{Boolean}  & \code{true}, \code{false}       & \code{True}, \code{False} & \code{true}, \code{false} \\
    integer    & \code{integer()}  & \code{int}, \code{Integer}   & \code{int}                      & \code{int}                & \code{Fixnum}, \\
               &                   & \code{long}, \code{Long}     &                                 &                           & \code{Bignum} \\
               &                   & \code{BigInteger}            &                                 &                           & \\
    float      & \code{float()}    & \code{double}, \code{Double} & \code{int frac}                 & \code{float}              & \code{Float} \\
               &                   &                              & \code{int exp}                  &                           & \\
               &                   &                              & \code{int frac exp}             &                           & \\
    string     & \code{string()}   & \code{String}                & \code{string}                   & \code{str}                & \code{String} \\
    binary     & \code{binary()}   & \code{byte[]}                & \code{string}                   & \code{bytearray}          & \code{String} \\
               &                   &                              & \footnotesize{(base64-encoded)} &                           & \\
    list(type) & \code{[type()]}   & \code{List<Object>}          & \code{array}                    & \code{list}               & \code{Array} \\
    JSON       & \code{json_obj()}\tnote{*} & \code{Map<String, Object>} & \code{object}            & \code{dict}               & \code{Hash}\\
    custom     & \code{any()}      & \code{OtpErlangObject}       & \emph{/}                        & \emph{/}                  & \emph{/} \\
    \bottomrule
    \end{tabular}
    \begin{tablenotes}
      \item[*] ~\vspace{-1.5em}%
\begin{lstlisting}[language=erlang]
json_obj() :: {struct, [Key::atom() | string(), Value::json_val()]}
json_val() :: string() | number() | json_obj() | {array, [any()]} | true | false | null
\end{lstlisting}
    \end{tablenotes}
    \caption{Types supported by the \scalaris{} APIs}
    \label{tab.api.supported_types}
  \end{threeparttable}
\end{table}

\subsection{Supported Operations}
\label{sec:apis.ops}

Most operations are available to all APIs, but some (especially convenience
methods) are API- or language-specific. The following paragraphs
provide a brief overview of what is available to which API. For a full
reference, see the documentation of the specific API.

\subsubsection{Transaction Layer}

\paragraph{Read}
Reads the value stored at a given key using quorum read.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_tx:read(Key)}\\
Java:   & \code{TransactionSingleOp.read(Key)}\\
JSON:   & \code{tx.yaws/read(Key)}\\
Python: & \code{TransactionSingleOp.read(Key)}\\
Ruby:   & \code{TransactionSingleOp.read(Key)}
\end{tabular}

\paragraph{Write}
Writes a value to a given key.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_tx:write(Key, Value)}\\
Java:   & \code{TransactionSingleOp.write(Key, Value)}\\
JSON:   & \code{tx.yaws/write(Key, Value)}\\
Python: & \code{TransactionSingleOp.write(Key, Value)}\\
Ruby:   & \code{TransactionSingleOp.write(Key, Value)}
\end{tabular}

\paragraph{``Add to'' \& ``Delete from'' List Operations}
For the list stored at a given key, first add all elements from a given list,
then remove all elements from a second given list.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_tx:add_del_on_list(Key, ToAddList, ToRemoveList)}\\
Java:   & \code{TransactionSingleOp.addDelOnList(Key, ToAddList, ToRemoveList)}\\
JSON:   & \code{tx.yaws/add_del_on_list(Key, ToAddList, ToRemoveList)}\\
Python: & \code{TransactionSingleOp.add_del_on_list(Key, ToAddList, ToRemoveList)}\\
Ruby:   & \code{TransactionSingleOp.add_del_on_list(Key, ToAddList, ToRemoveList)}
\end{tabular}

\paragraph{Add to a number}
Adds a given number to the number stored at a given key.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_tx:add_on_nr(Key, ToAddNumber)}\\
Java:   & \code{TransactionSingleOp.addOnNr(Key, ToAddNumber)}\\
JSON:   & \code{tx.yaws/add_on_nr(Key, ToAddList, ToAddNumber)}\\
Python: & \code{TransactionSingleOp.add_on_nr(Key, ToAddNumber)}\\
Ruby:   & \code{TransactionSingleOp.add_on_nr(Key, ToAddNumber)}
\end{tabular}

\paragraph{Atomic Test and Set}
Writes the given (new) value to a key if the current value is equal to the
given old value.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_tx:test_and_set(Key, OldValue, NewValue)}\\
Java:   & \code{TransactionSingleOp.testAndSet(Key, OldValue, NewValue)}\\
JSON:   & \code{tx.yaws/add_on_nr(Key, OldValue, NewValue)}\\
Python: & \code{TransactionSingleOp.test_and_set(Key, OldValue, NewValue)}\\
Ruby:   & \code{TransactionSingleOp.test_and_set(Key, OldValue, NewValue)}
\end{tabular}

\paragraph{Bulk Operations}
Executes multiple requests, i.e. operations, where each of them will be
committed.

\emph{Collecting requests and executing all of them in a single call yields
better performance than executing all on their own.}

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_tx:req_list_commit_each(RequestList)}\\
Java:   & \code{TransactionSingleOp.req_list(RequestList)}\\
JSON:   & \code{tx.yaws/req_list_commit_each(RequestList)}\\
Python: & \code{TransactionSingleOp.req_list(RequestList)}\\
Ruby:   & \code{TransactionSingleOp.req_list(RequestList)}
\end{tabular}

\subsubsection{Transaction Layer (with TLog)}

\paragraph{Read (with TLog)}
Reads the value stored at a given key using quorum read as an additional part
of a previous transaction or for starting a new one \emph{(no auto-commit!)}.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_tx:read(TLog, Key)}\\
Java:   & \code{Transaction.read(Key)}\\
JSON:   & \code{n/a} - use \code{req_list}\\
Python: & \code{Transaction.read(Key)}\\
Ruby:   & \code{Transaction.read(Key)}
\end{tabular}

\paragraph{Write (with TLog)}
Writes a value to a given key as an additional part
of a previous transaction or for starting a new one \emph{(no auto-commit!)}.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_tx:write(TLog, Key, Value)}\\
Java:   & \code{Transaction.write(Key, Value)}\\
JSON:   & \code{n/a} - use \code{req_list}\\
Python: & \code{Transaction.write(Key, Value)}\\
Ruby:   & \code{Transaction.write(Key, Value)}
\end{tabular}

\paragraph{``Add to'' \& ``Delete from'' List Operations (with TLog)}
For the list stored at a given key, first add all elements from a given list,
then remove all elements from a second given list as an additional part
of a previous transaction or for starting a new one \emph{(no auto-commit!)}.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_tx:add_del_on_list(TLog, Key, ToAddList, ToRemoveList)}\\
Java:   & \code{Transaction.addDelOnList(Key, ToAddList, ToRemoveList)}\\
JSON:   & \code{n/a} - use \code{req_list}\\
Python: & \code{Transaction.add_del_on_list(Key, ToAddList, ToRemoveList)}\\
Ruby:   & \code{Transaction.add_del_on_list(Key, ToAddList, ToRemoveList)}
\end{tabular}

\paragraph{Add to a number (with TLog)}
Adds a given number to the number stored at a given key as an additional part
of a previous transaction or for starting a new one \emph{(no auto-commit!)}.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_tx:add_on_nr(TLog, Key, ToAddNumber)}\\
Java:   & \code{Transaction.addOnNr(Key, ToAddNumber)}\\
JSON:   & \code{n/a} - use \code{req_list}\\
Python: & \code{Transaction.add_on_nr(Key, ToAddNumber)}\\
Ruby:   & \code{Transaction.add_on_nr(Key, ToAddNumber)}
\end{tabular}

\paragraph{Atomic Test and Set (with TLog)}
Writes the given (new) value to a key if the current value is equal to the
given old value as an additional part
of a previous transaction or for starting a new one \emph{(no auto-commit!)}.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_tx:test_and_set(TLog, Key, OldValue, NewValue)}\\
Java:   & \code{Transaction.testAndSet(Key, OldValue, NewValue)}\\
JSON:   & \code{tx.yaws/test_and_set(Key, OldValue, NewValue)}\\
Python: & \code{Transaction.test_and_set(Key, OldValue, NewValue)}\\
Ruby:   & \code{Transaction.test_and_set(Key, OldValue, NewValue)}
\end{tabular}

\paragraph{Bulk Operations (with TLog)}
Executes multiple requests, i.e. operations, as an additional part
of a previous transaction or for starting a new one \emph{(no auto-commit!)}.
Only one \code{commit} request is allowed per call!

\emph{Collecting requests and executing all of them in a single call yields
better performance than executing all on their own.}

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_tx:req_list(RequestList)}, \code{api_tx:req_list(TLog, RequestList)}\\
Java:   & \code{Transaction.req_list(RequestList)}\\
JSON:   & \code{tx.yaws/req_list(RequestList)}, \code{req_list(TLog, RequestList)}\\
Python: & \code{Transaction.req_list(RequestList)}\\
Ruby:   & \code{Transaction.req_list(RequestList)}
\end{tabular}

\subsubsection{Replication Layer}

\paragraph{Delete}
Tries to delete a value at a given key.

\emph{Warning: This can only be done outside the transaction layer and is thus not
absolutely safe. Refer to the following thread on the mailing list:
\url{http://groups.google.com/group/scalaris/browse_thread/thread/ff1d9237e218799}}.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_rdht:delete(Key)}, \code{api_rdht:delete(Key, Timeout)}\\
Java:   & \code{ReplicatedDHT.delete(Key)}, \code{ReplicatedDHT.delete(Key, Timeout)}\\
JSON:   & \code{rdht.yaws/delete(Key)}, \code{rdht.yaws/delete(Key, Timeout)}\\
Python: & \code{ReplicatedDHT.delete(Key)}, \code{ReplicatedDHT.delete(Key, Timeout)}\\
Ruby:   & \code{ReplicatedDHT.delete(Key)}, \code{ReplicatedDHT.delete(Key, Timeout)}
\end{tabular}

\paragraph{Get Replica Keys}
Gets the (hashed) keys used for the replicas of a given (user) key
(ref. Section~\nameref{sec:apis.ops.p2player}).

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_rdht:get_replica_keys(Key)}\\
Java:   & \code{n/a}\\
JSON:   & \code{n/a}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\subsubsection{P2P Layer}
\label{sec:apis.ops.p2player}

\paragraph{Hash Key}
Generates the hash of a given (user) key.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_dht:hash_key(Key)}\\
Java:   & \code{n/a}\\
JSON:   & \code{n/a}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Get Replica Keys}
Gets the (hashed) keys used for the replicas of a given (hashed) key.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_dht_raw:get_replica_keys(HashedKey)}\\
Java:   & \code{n/a}\\
JSON:   & \code{n/a}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Range Read}
Reads all Key-Value pairs in a given range of (hashed) keys.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_dht_raw:range_read(StartHashedKey, EndHashedKey)}\\
Java:   & \code{n/a}\\
JSON:   & \code{dht_raw.yaws/range_read(StartHashedKey, EndHashedKey)}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\subsubsection{P2P Layer (VM Management)}

\paragraph{Get Scalaris Version}
Gets the version of \scalaris{} running in the requested Erlang VM.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_vm:get_version()}\\
Java:   & \code{ScalarisVM.getVersion()}\\
JSON:   & \code{n/a}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Get Node Info}
Gets various information about the requested Erlang VM and the running
\scalaris{} code, e.g. \scalaris{} version, erlang version, memory use, uptime.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_vm:get_info()}\\
Java:   & \code{ScalarisVM.getInfo()}\\
JSON:   & \code{n/a}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Get Information about Different VMs}
Get connection info about other Erlang VMs running \scalaris{} nodes.
Note: This info is provided by the \erlmodule{cyclon} service built into
\scalaris{}.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_vm:get_other_vms(MaxVMs)}\\
Java:   & \code{ScalarisVM.getOtherVMs(MaxVMs)}\\
JSON:   & \code{n/a}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Get Number of Scalaris Nodes in the VM}
Gets the number of Scalaris nodes running inside the Erlang VM.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_vm:number_of_nodes()}\\
Java:   & \code{ScalarisVM.getNumberOfNodes()}\\
JSON:   & \code{n/a}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Get Scalaris Nodes}
Gets a list of Scalaris nodes running inside the Erlang VM.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_vm:get_nodes()}\\
Java:   & \code{ScalarisVM.getNodes()}\\
JSON:   & \code{n/a}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Add Scalaris Nodes}
Starts additional Scalaris nodes inside the Erlang VM.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_vm:add_nodes(Number)}\\
Java:   & \code{ScalarisVM.addNodes(Number)}\\
JSON:   & \code{n/a}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Shutdown Scalaris Nodes}
Gracefully kill some Scalaris nodes inside the Erlang VM. This will first move
the data from the nodes to other nodes and then shut them down.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_vm:shutdown_node(Name)},\newline
          \code{api_vm:shutdown_nodes(Count)}, \code{api_vm:shutdown_nodes_by_name(Names)}\\
Java:   & \code{ScalarisVM.shutdownNode(Name)},\newline
          \code{ScalarisVM.shutdownNodes(Number)}, \code{ScalarisVM.shutdownNodesByName(Names)}\\
JSON:   & \code{n/a}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Kill Scalaris Nodes}
Immediately kills some Scalaris nodes inside the Erlang VM.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_vm:kill_node(Name)},\newline
          \code{api_vm:kill_nodes(Count)}, \code{api_vm:kill_nodes_by_name(Names)}\\
Java:   & \code{ScalarisVM.killNode(Name)},\newline
          \code{ScalarisVM.killNodes(Number)}, \code{ScalarisVM.killNodesByName(Names)}\\
JSON:   & \code{n/a}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Shutdown the Erlang VM}
Gracefully shuts down all \scalaris{} nodes in the Erlang VM and then exits.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_vm:shutdown_vm()}\\
Java:   & \code{ScalarisVM.shutdownVM()}\\
JSON:   & \code{n/a}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Kill the Erlang VM}
Immediately kills all \scalaris{} nodes in the Erlang VM and then exits.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_vm:kill_vm()}\\
Java:   & \code{ScalarisVM.killVM()}\\
JSON:   & \code{n/a}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\subsubsection{P2P Layer (Monitoring)}

\paragraph{Get Node Info}
Gets some information about the node, e.g. \scalaris{} version, Erlang version,
number of \scalaris{} nodes in the VM.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_monitor:get_node_info()}\\
Java:   & \code{Monitor.getNodeInfo()}\\
JSON:   & \code{monitor.yaws/get_node_info()}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Get Node Performance}
Gets some performance information about the node, e.g. the average latency and
standard deviation of transactional operations.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_monitor:get_node_performance()}\\
Java:   & \code{Monitor.getNodePerformance()}\\
JSON:   & \code{monitor.yaws/get_node_performance()}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Get Service Info}
Gets some information about the whole \scalaris{} ring (may be estimated if no
management server is used). Includes the overall load and the total number of
nodes in the ring.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_monitor:get_service_info()}\\
Java:   & \code{Monitor.getServiceInfo()}\\
JSON:   & \code{monitor.yaws/get_service_info()}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Get Service Performance}
Gets some performance information about the whole \scalaris{} ring, e.g. the
average latency and standard deviation of transactional operations. Both are
aggregated and may be estimates.

\begin{tabular}{lp{14cm}}
Erlang  & \code{api_monitor:get_service_performance()}\\
Java:   & \code{Monitor.getServicePerformance()}\\
JSON:   & \code{monitor.yaws/get_service_performance()}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\subsubsection{Convenience Methods / Classes}

\paragraph{Connection Pool}
Implements a thread-safe pool of connections to Scalaris instances. Can be
instantiated with a fixed maximum number of connections. Connections are either taken from
a pool of available connections or are created on demand. If finished, a connection can be
put back into the pool.

\begin{tabular}{ll}
Erlang  & \code{n/a}\\
Java:   & \code{ConnectionPool}\\
JSON:   & \code{n/a}\\
Python: & \code{ConnectionPool}\\
Ruby:   & \code{n/a}
\end{tabular}

\paragraph{Connection Policies}
Defines policies on how to select a node to connect to from a set of
possible nodes and whether and how to automatically re-connect.

\begin{tabular}{ll}
Erlang  & \code{n/a}\\
Java:   & \code{ConnectionPolicy}\\
JSON:   & \code{n/a}\\
Python: & \code{n/a}\\
Ruby:   & \code{n/a}
\end{tabular}

\subsection{JSON API}
\label{sec.api.json}

\scalaris{} supports a JSON API for transactions. To minimize the necessary
round trips between a client and \scalaris{}, it uses request lists, which
contain all requests that can be done in parallel. The request list is then
send to a \scalaris{} node with a POST message. The result contains
a list of the results of the requests and - in case of a transaction - a
TransLog. To add further
requests to the transaction, the TransLog and another list of requests may
be send to \scalaris{}. This process may be repeated as often as necessary.
To finish the transaction, the request list can contain a 'commit' request
as the last element, which triggers the validation phase of the transaction
processing.
Request lists are also supported for single read/write operations, i.e.
every single operation is committed on its own.

The JSON-API can be accessed via the \scalaris{}-Web-Server running on port
8000 by default and pages under \code{<URL>/api/}.
For backwards-compatibility the page \code{<URL>/jsonrpc.yaws} provides some
functions otherwise provided by the different pages under \code{<URL>/api/} but
beware that this may be removed in future.
Other examples include \url{http://localhost:8000/api/tx.yaws}.
See Table~\sieheref{tab.api.layers} for a mapping of the layers to the
different pages.
Requests are issued by sending a JSON object with header
\code{"Content-type"="application/json"} to this URL.
The result will then be returned as a JSON object with the same content type.
The following table shows how both objects look like:

\begin{tabular}{p{0.45\textwidth}cp{0.45\textwidth}}
\bf Request & & \bf Result \\
\begin{lstlisting}[language=java]
{
  "jsonrpc": "2.0",
  "method" : "<method>",
  "params" : [<params>],
  "id"     : <number>
}
\end{lstlisting}
& &
\begin{lstlisting}[language=java]
{
  "result" : <result_object>,
  "id"     : <number>
}
\end{lstlisting}
\end{tabular}

The \code{id} in the request can be an arbitrary number which identifies the
request and is returned in the result.
The following operations (shown as \code{<method>(<params>)}) are currently
supported (the given result is the \code{<result_object>} mentioned above):
\begin{itemize}
  \item[] \hspace{-1.7em}generic, e.g. for testing - \code{<URL>/api/*.yaws}
  \item \code{nop(Value)} - no operation, result:
\begin{lstlisting}[language=java]
"ok"
\end{lstlisting}
  \item[] \hspace{-1.7em}single operations, e.g. read/write - \code{<URL>/api/tx.yaws}:
  \item \code{req_list_commit_each(<req_list_ce>)} - commit each request in the list, result:
\begin{lstlisting}[language=java]
{[{"status": "ok"} or {"status": "ok", "value": <json_value>} or
  {"status": "fail", "reason": "timeout" or "abort" or "not_found" or
                               "not_a_list" or "not_a_number"} or
  {"status": "fail", "reason": "key_changed", "value": <json_value>}]}
\end{lstlisting}
  \item \code{read(<key>)} - read the value at \code{key}, result:
\begin{lstlisting}[language=java]
{"status": "ok", "value", <json_value>} or
{"status": "fail", "reason": "timeout" or "not_found"}
\end{lstlisting}
  \item \code{write(<key>, <json_value>)} - write \code{value} (inside \code{json_value}) to \code{key}, result:
\begin{lstlisting}[language=java]
{"status": "ok"} or
{"status": "fail", "reason": "timeout" or "abort"}
\end{lstlisting}
  \item \code{add_del_on_list(<key>, ToAdd, ToRemove)} - adding to / removing from a list
  (for the list at \code{key} adds all values in the \code{ToAdd} list and
  then removes all values in the \code{ToRemove} list; if there is no value at
  \code{key}, uses an empty list - both value lists are \code{[<value>]}), result:
\begin{lstlisting}[language=java]
{"status": "ok"} or
{"status": "fail", "reason": "timeout" or "abort" or "not_a_list"}
\end{lstlisting}
  \item \code{add_on_nr(<key>, <value>)} - adding to a number
  (adds \code{value} to the number at \code{key} - both values must be numbers), result:
\begin{lstlisting}[language=java]
{"status": "ok"} or
{"status": "fail", "reason": "timeout" or "abort" or "not_a_number"}
\end{lstlisting}
  \item \code{test_and_set(<key>, OldValue, NewValue)} - atomic test-and-set
  (write \code{NewValue} to \code{key} if the current value is \code{OldValue}
   - both values are \code{<json_value>}), result:
\begin{lstlisting}[language=java]
{"status": "ok"} or
{"status": "fail", "reason": "timeout" or "abort" or "not_found"} or
{"status": "fail", "reason": "key_changed", "value": <json_value>}
\end{lstlisting}
  \item[] \hspace{-1.7em}transactions - \code{<URL>/api/tx.yaws}:
  \item \code{req_list(<req_list>)} - process a list of requests, result:
\begin{lstlisting}[language=java]
{"tlog": <tlog>,
 "results": [{"status": "ok"} or {"status": "ok", "value": <json_value>} or
             {"status": "fail", "reason": "timeout" or "abort" or "not_found" or
                                          "not_a_list" or "not_a_number"} or
             {"status": "fail", "reason": "key_changed", "value": <json_value>}]}
\end{lstlisting}
  \item \code{req_list(<tlog>, <req_list>)} - process a list of requests with a previous translog, result:
\begin{lstlisting}[language=java]
{"tlog": <tlog>,
 "results": [{"status": "ok"} or {"status": "ok", "value": <json_value>} or
             {"status": "fail", "reason": "timeout" or "abort" or "not_found" or
                                          "not_a_list" or "not_a_number"} or
             {"status": "fail", "reason": "key_changed", "value": <json_value>}]}
\end{lstlisting}
  \item[] \hspace{-1.7em}replication layer functions - \code{<URL>/api/rdht.yaws}:
  \item \code{delete(<key>)} - delete the value at \code{key}, default timeout 2s, result:
\begin{lstlisting}[language=java]
{"ok": <number>, "results": ["ok" or "locks_set" or "undef"]} or
{"failure": "timeout", "ok": <number>, "results": ["ok" or "locks_set" or "undef"]}
\end{lstlisting}
  \item \code{delete(<key>, Timeout)} - delete the value at \code{key} with a timeout of \code{Timeout} Milliseconds, result:
\begin{lstlisting}[language=java]
{"ok": <number>, "results": ["ok" or "locks_set" or "undef"]} or
{"failure": "timeout", "ok": <number>, "results": ["ok" or "locks_set" or "undef"]}
\end{lstlisting}
  \item[] \hspace{-1.7em}raw DHT functions - \code{<URL>/api/dht_raw.yaws}:
  \item \code{range_read(From, To)} - read a range of (raw) keys, result:
\begin{lstlisting}[language=java]
{"status": "ok" or "timeout",
 "value": [{"key": <key>, "value": <json_value>, "version": <version>}]}
\end{lstlisting}
  \item[] \hspace{-1.7em}monitor - \code{<URL>/api/monitor.yaws}:
  \item \code{get_node_info()} - gets some information about the node, result:
\begin{lstlisting}[language=java]
{"status": "ok" or "timeout",
 "value": [{"scalaris_version": <version_string>,
            "erlang_version": <version_string>,
            "dht_nodes": <number>}]}
\end{lstlisting}
  \item \code{get_node_performance()} - gets some performance information about the node, result:
\begin{lstlisting}[language=java]
{"status": "ok" or "timeout",
 "value": [{"latency_avg": <perf_data>, "latency_stddev": <perf_data>}]}
\end{lstlisting}
  \item \code{get_service_info()} - gets some information about the \scalaris{} ring, result:
\begin{lstlisting}[language=java]
{"status": "ok" or "timeout",
 "value": [{"total_load": <number>, "nodes": <number>}]}
\end{lstlisting}
  \item \code{get_service_performance()} - gets some performance information about the \scalaris{} ring, result:
\begin{lstlisting}[language=java]
{"status": "ok" or "timeout",
 "value": [{"latency_avg": <perf_data>, "latency_stddev": <perf_data>}]}
\end{lstlisting}
\end{itemize}

Note:
\begin{lstlisting}[language=java]
<json_value> = {"type": "as_is" or "as_bin", "value": <value>}
<operation> = {"read": <key>} or {"write", {<key>: <json_value>}} or
              {"add_del_on_list": {"key": <key>, "add": [<value>], "del": [<value>]}} or
              {"add_on_nr": {<key>: <value>}} or
              {"test_and_set": {"key": <key>, "old": <json_value>, "new": <json_value>}}
<req_list_ce> = [<operation>]
<req_list> = [<operation> or {"commit", _}]
<perf_data> = {<number>: <perf_val>,...}
\end{lstlisting}
The \code{<value>} inside \code{<json_value>} is either a base64-encoded
string representing a binary object (type = \code{"as_bin"}) or the value
itself (type = \code{"as_is"}).

\subsubsection{JSON-Example}

The following example illustrates the message flow:

%note: use tables inside tables instead of multicol for easier listings handling
\begin{longtable}{p{0.97\textwidth}}
\begin{tabular}{p{0.43\textwidth}cp{0.43\textwidth}}
\bf Client & & \hfill\bf \scalaris{} node \\
\end{tabular} \\
%
% request:
\begin{tabular}{p{0.43\textwidth}cp{0.43\textwidth}}
Make a transaction, that sets two keys & $\to$ & \\
\end{tabular}\vspace{-1.5em} \\
%
\begin{tabular}{p{0.78\textwidth}p{0.13\textwidth}}
\vspace{-1.5em}%
\begin{lstlisting}[language=java]
{"jsonrpc": "2.0",
 "method": "req_list",
 "params": [
  [ { "write": { "keyA": {"type": "as_is", "value": "valueA"} } },
    { "write": { "keyB": {"type": "as_is", "value": "valueB"} } },
    { "commit": "" } ]
 ],
 "id": 0
}
\end{lstlisting}
& \\
\end{tabular}\vspace{-1em} \\
%
% result:
\begin{tabular}{p{0.43\textwidth}cp{0.43\textwidth}}
 & $\leftarrow$ & \hfill{}\scalaris{} sends results back \\
\end{tabular}\vspace{-1.5em} \\

\begin{tabular}{p{0.13\textwidth}p{0.78\textwidth}}
&
\vspace{-1.5em}%
\begin{lstlisting}[language=java]
{"error": null,
 "result": {
  "results": [ {"status": "ok"}, {"status": "ok"}, {"status": "ok"} ],
  "tlog": <TLOG> // this is the translog for further operations!
 },
 "id": 0
}
\end{lstlisting} \\
\end{tabular}\vspace{-1em} \\
%
% request:
\begin{tabular}{p{0.43\textwidth}cp{0.43\textwidth}}
In a second transaction: Read the two keys & $\to$ & \\
\end{tabular}\vspace{-1.5em} \\
%
\begin{tabular}{p{0.78\textwidth}p{0.13\textwidth}}
\vspace{-1.5em}%
\begin{lstlisting}[language=java]
{"jsonrpc": "2.0",
 "method": "req_list",
 "params": [
  [ { "read": "keyA" },
    { "read": "keyB" } ]
 ],
 "id": 0
}
\end{lstlisting}
& \\
\end{tabular}\vspace{-1em} \\
%
% result:
\begin{tabular}{p{0.43\textwidth}cp{0.43\textwidth}}
 & $\leftarrow$ & \hfill{}\scalaris{} sends results back \\
\end{tabular}\vspace{-1.5em} \\

\begin{tabular}{p{0.13\textwidth}p{0.78\textwidth}}
&
\vspace{-1.5em}%
\begin{lstlisting}[language=java]
{"error": null,
 "result": {
  "results": [
   { "status": "ok", "value": {"type": "as_is", "value": "valueA"} },
   { "status": "ok", "value": {"type": "as_is", "value": "valueB"} }
  ],
  "tlog": <TLOG>
 },
 "id": 0
}
\end{lstlisting} \\
\end{tabular} \\
%
% request:
\begin{tabular}{p{0.43\textwidth}cp{0.43\textwidth}}
Calculate something with the read values and make further requests, here a
write and the commit for the whole transaction. Also include the latest
translog we got from \scalaris{} (named \code{<TLOG>} here). & $\to$ & \\
\end{tabular}\vspace{-1.5em} \\
%
\begin{tabular}{p{0.78\textwidth}p{0.13\textwidth}}
\vspace{-1.5em}%
\begin{lstlisting}[language=java]
{"jsonrpc": "2.0",
 "method": "req_list",
 "params": [
  <TLOG>,
  [ { "write": { "keyA": {"type": "as_is", "value": "valueA2"} } },
    { "commit": "" } ]
 ],
 "id": 0
}
\end{lstlisting}
& \\
\end{tabular}\vspace{-1em} \\
%
% result:
\begin{tabular}{p{0.43\textwidth}cp{0.43\textwidth}}
 & $\leftarrow$ & \hfill{}\scalaris{} sends results back \\
\end{tabular}\vspace{-1.5em} \\

\begin{tabular}{p{0.13\textwidth}p{0.78\textwidth}}
&
\vspace{-1.5em}%
\begin{lstlisting}[language=java]
{"error": null,
 "result": {
  "results": [ {"status": "ok"}, {"status": "ok"} ],
  "tlog": <TLOG>
 },
 "id": 0
}
\end{lstlisting} \\
\end{tabular} \\
\end{longtable}

Examples of how to use the JSON API are the Python and Ruby API which use JSON
to communicate with \scalaris{}.

%\subsection{Erlang}

\subsection{Java API}

The \code{scalaris.jar} provides a Java command line client as well as a
library for Java programs to access \scalaris{}. The library provides several
classes:

\begin{itemize}
\item \code{TransactionSingleOp} provides methods for reading and writing values.
\item \code{Transaction} provides methods for reading and writing values in transactions.
\item \code{ReplicatedDHT} provides low-level methods for accessing the replicated DHT of \scalaris{}.
\end{itemize}

For details regarding the API we refer the reader to the Javadoc:

\begin{lstlisting}[language=sh]
%> cd java-api
%> ant doc
%> firefox doc/index.html
\end{lstlisting}

\section{Command Line Interfaces}

\subsection{Java command line interface}

As mentioned above, the \code{scalaris.jar} file contains a small command line
interface client. For
convenience, we provide a wrapper script called \code{scalaris} which
sets up the Java environment:

\begin{lstlisting}[language=sh]
%> ./java-api/scalaris --noconfig --help
\end{lstlisting}
\lstinputlisting[language={}]{scalaris-client-java.out}

\code{read}, \code{write}, \code{delete} and similar operations can be used to read, write
and delete from/to the overlay, respectively. The others
provide debugging and testing functionality.

\begin{lstlisting}[language=]
%> ./java-api/scalaris -write foo bar
write(foo, bar)
%> ./java-api/scalaris -read foo
read(foo) == bar
\end{lstlisting}

Per default, the \code{scalaris} script tries to connect to a management
server at \code{localhost}. You can change the node it connects to (and
further connection properties) by adapting the values defined in
\code{java-api/scalaris.properties}.

\subsection{Python command line interface}

\begin{lstlisting}[language=sh]
%> ./python-api/scalaris --help
\end{lstlisting}
\lstinputlisting[language={}]{scalaris-client-python.out}

\subsection{Ruby command line interface}

\begin{lstlisting}[language=sh]
%> ./ruby-api/scalaris --help
\end{lstlisting}
\lstinputlisting[language={}]{scalaris-client-ruby.out}

\section{Using \scalaris{} from Erlang}
\label{chapter.systemuse.usingfromerl}

In this section, we will describe how to use \scalaris{} with two small
examples. After having build \scalaris{} as described
in~\ref{chapter.downloadinstall}, \scalaris{} can be run from the source
directory directly.

\subsection{Running a \scalaris{} Cluster}
In this example, we will set up a simple \scalaris{} cluster consisting of
up to five nodes running on a single computer.

\paragraph{Adapt the configuration.}
The first step is to adapt the configuration to your needs. We use the
sample local configuration from~\ref{chapter.runscalaris.runtime_config},
copy it to \code{bin/scalaris.local.cfg} and add a number of different known
hosts. Note that the management server will run on the same port as the
first node started in the example, hence we adapt its port as well.

\begin{lstlisting}
{listen_ip, {127,0,0,1}}.
{mgmt_server, {{127,0,0,1},14195,mgmt_server}}.
{known_hosts, [{{127,0,0,1},14195, service_per_vm},
                {{127,0,0,1},14196, service_per_vm},
                {{127,0,0,1},14197, service_per_vm},
                {{127,0,0,1},14198, service_per_vm}
                % Although we will be using 5 nodes later, only 4 are added as known nodes.
            ]}.
\end{lstlisting}

\paragraph{Bootstrapping.}
\label{par:Bootstrapping}

In a shell (from now on called \code{S1}), start the first node ("premier"):
\begin{lstlisting}[language=sh]
./bin/scalarisctl -m -n premier@127.0.0.1 -p 14195 -y 8000 -s -f start
\end{lstlisting}
The \code{-m} and \code{-f} options instruct \code{scalarisctl} to start the
management server and the first\_node
(see Section~\sieheref{user.config.scalarisctl} for further details on \code{scalarisctl}).
Note that the command above will
produce some output about unknown nodes. This is expected, as some nodes
defined in the configuration file above are not started yet.

After you run the above command and no further error occurred, you can query
the locally available nodes using \code{scalarisctl}. Enter into a new shell
(called \code{MS}):
\begin{lstlisting}[language=sh]
./bin/scalarisctl list
epmd: up and running on port 4369 with data:
name premier at port 47235
\end{lstlisting}

\scalaris{} also contains a webserver. You can access it by pointing your
browser to \url{http://127.0.0.1:8000} (or the respective IP address of the
node). With the above example, you can see the first node ("premier") and
its management role.

\paragraph{Adding Nodes.}
\label{par:AddingNodes}

We will now add four additional nodes to the cluster. Use a new shell
(\code{S2} to \code{S5}) for each of the following commands. Each newly
added node is a "real" \scalaris{} node and could run on another physical
computer than the other nodes.
\begin{lstlisting}[language=sh]
./bin/scalarisctl -n second@127.0.0.1 -p 14196 -y 8001 -s start
./bin/scalarisctl -n n3@127.0.0.1 -p 14197 -y 8002 -s start
./bin/scalarisctl -n n4@127.0.0.1 -p 14198 -y 8003 -s start
./bin/scalarisctl -n n5@127.0.0.1 -p 14199 -y 8004 -s start
\end{lstlisting}
Note that the last added nodes should not report a node as not reachable.

The management server should now report that the nodes have indeed joined
\scalaris{} successfully. Query \code{scalarisctl}:
\begin{lstlisting}[language=sh]
./bin/scalarisctl list
epmd: up and running on port 4369 with data:
name n5 at port 47801
name n4 at port 54614
name n3 at port 41710
name second at port 44329
name premier at port 44862
\end{lstlisting}
The actual output might differ, as the port numbers are assigned by the
operating system.

Each node offers a web console. Point your browser to any url for
\url{http://127.0.0.1:8001} to \url{http://127.0.0.1:8004}. Observe that
all nodes claim the cluster ring to consist of 5 nodes.

The web interface of node \code{premier} differs from the other
interfaces. This is due to the fact that the management server is running on
this node, adding additional information to the web interface.

\paragraph{Entering Data Using the Web Interface.}
A node's web interface can be used to query and enter data into \scalaris{}. To
try this, point your browser to \url{http://127.0.0.1:8000} (or any of the
other nodes) and use the provided HTML form.

\begin{enumerate}
    \item Lookup key \code{hello}. This will return \lstinline|{fail,not_found}|
    \item Add new keys \code{k1} and \code{k2} with values \code{v1} and
      \code{v2}, respectively. Then, lookup that key on the current and one
      of the other nodes. This should return \lstinline|{ok,"v1"}| and
      \lstinline|{ok, "v2"}| on both nodes.
    \item Update the key \code{k1} by adding it on any node with value
      \code{v1updated}.
    \item Update the key \code{k2} by adding it on any node with value
      \code{v2updated}.  Lookup the key again and you should receive
      \lstinline|{ok, v2updated}|
\end{enumerate}

\paragraph{Simulating Node Failure.}
To simulate a node failure, we will simply stop \code{n4} using
\code{scalarisctl}:

\begin{lstlisting}[language=sh]
./bin/scalarisctl -n n4@127.0.0.1 stop
\end{lstlisting}

Other nodes will notice the crash of \code{n4}. By querying the available
nodes in the shell MS again, you will now see only 4 nodes.

Although the node \code{n4} left the system, the data in the system is still
consistent. Try to query the keys you added above. You should receive the
values for each.

We will start a new node with the name \code{n4} again:
\begin{lstlisting}[language=sh]
./bin/scalarisctl -n n4@127.0.0.1 -p 14198 -y 8003 -s start
\end{lstlisting}

The node list (again, query \code{scalarisctl} in shell MS) will report
\code{n4} as alive again. You can still lookup the keys from above and
should also receive the same result for the queries.

After running the above, we went from a five-node cluster to a 4-node
cluster and back to a five-node cluster without any data loss due to a
leaving node. The system was not unavailable for users and would have served
any user requests without violating the data consistency or availability.

\paragraph{Controlling \scalaris{}  Using the Erlang Shell.}
The calls to \code{scalarisctl} above which started a new \scalaris{} node
ended within an Erlang shell. Each of those shells can be used to control a
local \scalaris{} node and issue queries to the distributed database. Enter
shell \code{S1} and hit <return> to see the Erlang shell prompt. Now, enter
the following commands and check that the output is similar to the one
provided here. You can stop the Erlang shell using \code{quit().}, which
then also stops the corresponding \scalaris{} node.

\begin{lstlisting}
(premier@127.0.0.1)1> api_tx:read("k0").
{fail,not_found}
(premier@127.0.0.1)2> api_tx:read("k1").
{ok,"v1updated"}
(premier@127.0.0.1)3> api_tx:read("k2").
{ok,"v2updated"}
(premier@127.0.0.1)4> api_tx:read(<<"k1">>).
{ok,"v1updated"}
(premier@127.0.0.1)5> api_tx:read(<<"k2">>).
{ok,"v2updated"}
(premier@127.0.0.1)6> api_tx:write(<<"k3">>,<<"v3">>).
{ok}
(premier@127.0.0.1)7> api_tx:read(<<"k3">>).
{ok,<<"v3">>}
(premier@127.0.0.1)8> api_tx:read("k3").
{ok,<<"v3">>}
(premier@127.0.0.1)9> api_tx:write(<<"k4">>,{1,2,3,four}).
{ok}
(premier@127.0.0.1)10> api_tx:read("k4").
{ok,{1,2,3,four}}
\end{lstlisting}

\paragraph{Attaching a Client to \scalaris{}.}
Now we will connect a true client to our 5 nodes \scalaris{} cluster. This
client will not be a \scalaris{} node itself and thus represents a user
application interacting with \scalaris{}.

We use a new shell to run an Erlang shell to do remote API calls to the
server nodes.

\begin{lstlisting}[language=sh]
erl -name client@127.0.0.1 -hidden -setcookie 'chocolate chip cookie'
\end{lstlisting}

The requests to \scalaris{} will be done using \code{rpc:call/4}. A
production system would have some more sophisticated client side module,
dispatching requests automatically to server nodes, for example.

\begin{lstlisting}
(client@127.0.0.1)1> net_adm:ping('n3@127.0.0.1').
pong
(client@127.0.0.1)2> rpc:call('n3@127.0.0.1', api_tx, read, [<<"k0">>]).
{fail,not_found}
(client@127.0.0.1)3> rpc:call('n3@127.0.0.1', api_tx, read, [<<"k4">>]).
{ok,{1,2,3,four}}
(client@127.0.0.1)4> rpc:call('n4@127.0.0.1', api_tx, read, [<<"k4">>]).
{ok,{1,2,3,four}}
(client@127.0.0.1)5> rpc:call('n5@127.0.0.1', api_tx, write, [<<"num5">>,55]).
{ok}
(client@127.0.0.1)6> rpc:call('n3@127.0.0.1', api_tx, read, [<<"num5">>]).
{ok,55}
(client@127.0.0.1)7> rpc:call('n2@127.0.0.1', api_tx, add_on_nr, [<<"num5">>,2]).
{badrpc,nodedown}
(client@127.0.0.1)8> rpc:call('second@127.0.0.1', api_tx, add_on_nr, [<<"num5">>,2]).
{ok}
(client@127.0.0.1)9> rpc:call('n3@127.0.0.1', api_tx, read, [<<"num5">>]).
{ok,57}
(client@127.0.0.1)10> rpc:call('n4@127.0.0.1', api_tx, test_and_set, [<<"num5">>,57,59]).
{ok}
(client@127.0.0.1)11> rpc:call('n5@127.0.0.1', api_tx, read, [<<"num5">>]).
{ok,59}
(client@127.0.0.1)12> rpc:call('n4@127.0.0.1', api_tx, test_and_set, [<<"num5">>,57,55]).
{fail,{key_changed,59}}
(client@127.0.0.1)13> rpc:call('n3@127.0.0.1', api_tx, read, [<<"num5">>]).
{ok,59}
(client@127.0.0.1)14> rpc:call('n5@127.0.0.1', api_tx, test_and_set,
                               [<<"k2">>,"v2updated",<<"v2updatedTWICE">>]).
{ok}
(client@127.0.0.1)15> rpc:call('n4@127.0.0.1', api_tx, read, [<<"k2">>]).
{ok,<<"v2updatedTWICE">>}
(client@127.0.0.1)16> rpc:call('n3@127.0.0.1', api_tx, add_on_nr, [<<"num5">>,-4]).
{ok}
(client@127.0.0.1)17> rpc:call('n4@127.0.0.1', api_tx, read, [<<"num5">>]).
{ok,55}
(client@127.0.0.1)18> q().
ok
\end{lstlisting}

To show that the above calls actually worked with \scalaris{}, connect
another client to the cluster and read updates made by the first:

\begin{lstlisting}[language=sh]
erl -name clientagain@127.0.0.1 -hidden -setcookie 'chocolate chip cookie'
\end{lstlisting}

\begin{lstlisting}
(clientagain@127.0.0.1)1> net_adm:ping('n5@127.0.0.1').
pong
(clientagain@127.0.0.1)2> rpc:call('n4@127.0.0.1', api_tx, read, [<<"k0">>]).
{fail,not_found}
(clientagain@127.0.0.1)3> rpc:call('n4@127.0.0.1', api_tx, read, [<<"k1">>]).
{ok,"v1updated"}
(clientagain@127.0.0.1)4> rpc:call('n3@127.0.0.1', api_tx, read, [<<"k2">>]).
{ok,<<"v2updatedTWICE">>}
(clientagain@127.0.0.1)5> rpc:call('second@127.0.0.1', api_tx, read, [<<"num5">>]).
{ok,55}
\end{lstlisting}

\paragraph{Shutting Down \scalaris{}.}
Firstly, we list the available nodes using \code{scalarisctl} using the
shell \code{MS}.

\begin{lstlisting}[language=sh]
./bin/scalarisctl list
epmd: up and running on port 4369 with data:
name n4 at port 52504
name n5 at port 47801
name n3 at port 41710
name second at port 44329
name premier at port 44862
\end{lstlisting}

Secondly, we shut down each of the nodes:
\begin{lstlisting}[language=sh]
./bin/scalarisctl -n second@127.0.0.1 stop
'second@127.0.0.1'
./bin/scalarisctl -n n3@127.0.0.1 stop
'n3@127.0.0.1'
./bin/scalarisctl -n n4@127.0.0.1 stop
'n4@127.0.0.1'
./bin/scalarisctl -n n5@127.0.0.1 stop
'n5@127.0.0.1'
\end{lstlisting}

Only the first node remains:

\begin{lstlisting}[language=sh]
./bin/scalarisctl list
epmd: up and running on port 4369 with data:
name premier at port 44862

./bin/scalarisctl -n premier@127.0.0.1 stop
'premier@127.0.0.1'
./bin/scalarisctl list
epmd: up and running on port 4369 with data:
(nothing)
\end{lstlisting}

The \scalaris{} API offers more transactional operations than just
single-key read and write.  The next part of this section will describe how
to build transaction logs for atomic operations and how \scalaris{}
handles conflicts in concurrently running transactions. See the module
\lstinline{api_tx} for more functions to access the data layer of
\scalaris{}.

\subsection{Transaction}
In this section, we will describe how to build transactions using
\lstinline{api_tx:req_list(Tlog, List)} on the client side.

The setup is similar to the five nodes cluster in the previous section.  To
simplify the example all API calls are typed inside the Erlang shells of
nodes \code{n4} and \code{n5}.

Consider two concurrent transactions \code{A} and \code{B}. \code{A} is a
long-running operation, whereas \code{B} is only a short transaction.  In
the example, \code{A} starts before \code{B} and \code{B} ends before
\code{A}. \code{B} is "timely" nested in \code{A} and disturbs \code{A}.

\paragraph{Single Read Operations.}
We first issue two read operations on nodes \code{n4, n5} to see that we are
working on the same state for key \code{k1}:

\begin{lstlisting}
(n4@127.0.0.1)10> api_tx:read(<<"k1">>).
{ok,<<"v1">>}
(n5@127.0.0.1)17> api_tx:read(<<"k1">>).
{ok,<<"v1">>}
\end{lstlisting}

\paragraph{Create Transaction Logs and Add Operations.}
Now, we create two transaction logs for the transactions and add the
operations which are to be run atomically. \code{A} will be created on node
\code{n5}, \code{B} on \code{n4}:
\begin{lstlisting}
(n5@127.0.0.1)18> T5longA0 = api_tx:new_tlog().
[]
(n5@127.0.0.1)19> {T5longA1, R5longA1} = api_tx:req_list(T5longA0, [{read, <<"k1">>}]).
{[{76,<<"k1">>,1,75,'$empty'}],[{ok,<<"v1">>}]}
(n4@127.0.0.1)11> T4shortB0 = api_tx:new_tlog().
[]
(n4@127.0.0.1)12> {T4shortB1, R4shortB1} = api_tx:req_list(T4shortB0, [{read, <<"k1">>}]).
{[{76,<<"k1">>,1,75,'$empty'}],[{ok,<<"v1">>}]}
(n4@127.0.0.1)13> {T4shortB2, R4shortB2} = api_tx:req_list(T4shortB1,
                                             [{write, <<"k1">>, <<"v1Bshort">>}]).
{[{77,<<"k1">>,1,75, <<131,109,0,0,0,8,118,49,66,115,104,111,114,116>>}],
 [{ok}]}
(n4@127.0.0.1)14> {T4shortB3, R4shortB3} = api_tx:req_list(T4shortB2, [{read, <<"k1">>}]).
{[{77,<<"k1">>,1,75, <<131,109,0,0,0,8,118,49,66,115,104,111,114,116>>}],
 [{ok,<<"v1Bshort">>}]}
\end{lstlisting}

To finish the transaction log for \code{B}, we add
\lstinline|{commit}|. This operation should return an \code{ok}:

\begin{lstlisting}
(n4@127.0.0.1)15> {T4shortB4, R4shortB4} = api_tx:req_list(T4shortB3, [{commit}]).
{[],[{ok}]}
(n4@127.0.0.1)16> [R4shortB1,R4shortB2,R4shortB3,R4shortB4].
[[{ok,<<"v1">>}],[{ok}],[{ok,<<"v1Bshort">>}],[{ok}]]
\end{lstlisting}
This concludes the creation of \code{B}. Now we will try to commit the long
running transaction \code{A} after reading the key \code{k1} again. This and
further attempts to write the key will fail, as the transaction \code{B}
wrote this key since \code{A} started.
\begin{lstlisting}
(n5@127.0.0.1)20> {T5longA2, R5longA2} = api_tx:req_list(T5longA1, [{read, <<"k1">>}]).
{[{76,<<"k1">>,2,{fail,abort},'$empty'}],
 [{ok,<<"v1Bshort">>}]}                                % <-- SEE #### FAIL and ABORT ####
(n5@127.0.0.1)21> {T5longA3, R5longA3} = api_tx:req_list(T5longA2,
                                           [{write, <<"k1">>,<<"v1Along">>}]).
{[{76,<<"k1">>,2,{fail,abort},'$empty'}],[{ok}]}
(n5@127.0.0.1)22> {T5longA4, R5longA4} = api_tx:req_list(T5longA3, [{read, <<"k1">>}]).
{[{76,<<"k1">>,2,{fail,abort},'$empty'}],
 [{ok,<<"v1Bshort">>}]}
(n5@127.0.0.1)23> {T5longA5, R5longA5} = api_tx:req_list(T5longA4, [{commit}]).
{[],[{fail,abort,[<<"k1">>]}]}                         % <-- SEE #### FAIL and ABORT ####
(n4@127.0.0.1)17> api_tx:read(<<"k1">>).
{ok,<<"v1Bshort">>}
(n5@127.0.0.1)24> api_tx:read(<<"k1">>).
{ok,<<"v1Bshort">>}
\end{lstlisting}

As expected, the first coherent commit \code{B} constructed on \code{n4} has
won.

Note that in a real system, operations in \lstinline|api_tx:req_list(Tlog, List)| should be grouped together with a trailing \lstinline|{commit}| as
far as possible. The individual separation of all reads, writes and commits
was done here on purpose to study the transactional behaviour.
